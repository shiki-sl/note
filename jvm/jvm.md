#深入理解jvm笔记
讲什么:
- 基于jdk8
- 各个jdk版本通用的最核心最重要的jvm

并不会讲
- 全部的jvm参数,讲常见且重要的

##classloader
- 在java代码中类型的加载,连接与初始化过程都是在程序运行期间完成的
- 提供了更大的灵活性,增加了更多的可能性
类型可以动态生成:动态代理

###类得加载连接与初始化
[详情](./classLoader.md)
- 加载:查找并加载类的二进制数据
    - 类加载的最终产品是位于内存中的Class对象
    - Class对象封装了类在方法区内的数据结构,并且向Java程序员提供了访问方法区内的数据结构的接口
- 连接
    - 验证:确保被加载类的正确性
    - 准备:为类的**静态变量**分配内存,并将其初始化为默认值,但是再到达初始化之前,类变量都没有初始化为真正的初始值
    - 解析:**把类中的符号引用转换为直接引用**
- **初始化:为类的静态变量赋予正确的初始值**
java程序对类的使用方式可分为两种
- 主动使用
    - 子类无论是访问父类的静态变量还是静态方法都是对父类的主动使用,而并不是对子类的主动使用
    - 调用ClassLoader类的loadClass方法加载一个类,并不是对类的主动使用,不会导致类的初始化
- 被动使用
所有的java虚拟机实现必须在每个类或接口被java程序**首次主动使用**时才**初始化**他们
类实例化: 
1. 为新的对象分配内存
2. 为实例变量赋默认值
3. 为实例变量赋正确的初始值

##数组加载
数组加载不经过类加载器,是java虚拟机在运行时创建的,对象数组的类加载器是数组当中元素的类加载器加载的,而基本类型的数组没有类加载器

##父委托机制
- 若有一个类加载器能够成功加载Test类,那么这个类加载器被成为**定义类加载器**,所有能成功返回Class对象引用的类加载器(包括定义类加载器)都被称为**初始类加载器**
- 类加载器的双亲委托模型的好处
    1. 可以确保Java核心库的类型安全:所有的Java应用都至少会引用java.lang.Object类,也就是说在运行期,java.lang.Object这个类会被加载到Java虚拟机中;如果这个加载过程是由java应用自己的类加载器所完成的,那么很可能就会在JVM中存在多个版本的java.lang.Object类,而且这些类之间还是互不兼容,相互不可见的(正是命名空间在发挥作用)
    借助于双亲委托机制,java核心类库中的类加载工作都是由启动类加载器来统一完成,从而确保了java应用所使用的都是同一个版本的java核心类库,他们之间是相互兼容的
    2. 可以确保java核心类库所提供的类不会被自定义的类所替代
    3. 不同的类加载器可以为相同名称(binary name)的类创建额外的命名空间,相同名称的类可以并存在java虚拟机中,只需要用不同的类加载器来加载他们即可,不同的类加载器所加载的类之间是不兼容的,这就相当于在java虚拟机内部创建了一个又一个相互隔离的java类空间,这类技术在很多框架中都得到了实际应用
    - 内建于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的java平台类,当JVM启动是,一块特殊的机器码就会运行,它会加载扩展类加载器与系统类加载器,这块特殊的机器码就叫做启动类加载器(Bootstrap)
    启动类加载器不是java类,二期他的加载器都是java类.启动类加载器是特定于平台的机器指令,他负责开启整个加载过程
    所有的类加载器(除了启动类加载器)都被实现为java类,启动类加载器还会加载供JRE正常运行所需要的基本组件,这包括java.util与java.lang包中的类等等

##命名空间
- 每个类加载器都有自己的命名空间,**命名空间由该加载器及所有父加载器所加载的类组成**用一个命名空间内的类是相互可见的,但是相互调用取决与访问修饰符
- 每个类加载器都有自己的命名空间,**命名空间由该加载器及所有父加载器所加载的类组成***子加载器可以访问父加载器,父加载器不能访问子加载器*
- 在同一个命名空间中,不会出现全限定类名一致的两个类
- 在不同的命名空间中,有可能会出现类的完整名字(包括类的包名)相同的两个类**相同的类出现ClassCastException可能是类加载器的不同**

##类的卸载
- 当MyTest类被加载,连接和初始化后,他的生命周期就开始了; 当代表MyTest类的Class对象不再被引用,即不可触及时,Class对象就会结束生命周期,MyTest类在方法区内的数据也会被卸载,从而结束MyTest类的生命周期
- 一个类何时结束生命周期,取决于代表它的Class对象何时结束生命周期
- **java虚拟机自带的类加载器加载的类,始终不会被卸载** java虚拟机本身会始终引用这些类加载器.而这些加载器则会使用引用他们所加载的类的Class对象,因此这些Class对象始终是可触及的
- 由用户自定义的类加载器是可以被卸载的
- 运行程序时,MyTest类由loader1加载,在类加载器的内部实现中,用一个java集合来存放所加载类的引用; 另一方面,一个Class对象总会引用它的类加载器,调用Class对象的getClassLoader()方法,就能获得他的类加载器; 由此可见,代表MyTest类的Class实例与loader1之间为双向关联关系.
- 一个类的实例总是引用代表这个类的Class对象; 在Object类中定义了getClass()方法,这个方法返回代表对象所属类的Class对象引用; 此外所有Java类都有一个静态属性class,它代表这个类的Class对象

##线程上下文类加载器与双亲委派模型的打破
- 当前类加载器
每个类都会使用自己的类加载器(即加载自己的类加载器)去加载器他的类(指锁依赖的类)
如果ClassX引用了ClassY,那么ClassX的类加载器就会去加载ClassY(ClassY尚未被加载)
- 线程上下文类加载器
线程上下文类加载器是从JDK1.2开始引入的,类Thread中的getContextClassLoader()与setContextClassLoader(ClassLoader cl)分别用来获取和设置上下文类加载器
如果没有通过setContextClassLoader(ClassLoader cl)进行设置的话,线程将继承其父线程的上下文类加载器Java应用运行时的初始线程的上下文类加载器; 在线程中运行的代码可以通过该类加载器来加载类与资源
- 线程上下文类加载器的重要性
**SPI(Service Provider Interface)**
父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所指定的classloader加载的类; 这就改变了父类加载器不能使用子类加载器或是其他没有直接父子关系的classloader加载类的情况,即改变了双亲委托模型
线程上下文类加载器就是当前线程的Current ClassLoader
在双亲委托模型下,类的加载是由下至上的,即下层的类加载器会委托上层进行加载; 但是对SPI来说,有些接口是java核心库所提供的,而java核心库是由启动类加载器来加载的,而这些接口的事先去来自不同的jar包(厂商提供), java的启动类加载器是不会加载其他来源的jar包,这样传统的双亲委托模型就无法满足SPI的要求,而通过给当前县城设置上下文类加载器, 就可以由设置得上下文类加载器来实现对于接口实现类的加载
- 线程上下文类加载器的一般使用模式(获取 - 使用 - 还原)
```
ClassLoader classLoader = Thread.currentThread.getContextClassLoader();
try{
    Thread.currentThread().setContextClassLoader(targetTccl);
    myMethod();
}finally{
    Thread.currentThread().setContextClassLoader(classLoader);
}
```
如果一个类由类加载器A加载,那么这个类的依赖类也是由相同的类加载器加载的(未加载的情况下) 
ContextClassLoader的作用就是为了破坏Java的类加载委托机制
当高层提供了统一的接口让底层去实现, 同时又要在高层加载(或者实例化)低层的类时, 就必须通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类
> tomcat 正好与传统双亲委托加载机制相反 先由子类进行加载,加载不了再使用父类进行加载,也是selvect规范所推荐的一种方式

##[class字节码](./class字节码.md)

现在JVM在执行Java代码时,通常都会将解释执行与编译执行二者结合起来进行,
所谓解释执行,就是通过解释器来读取字节码,遇到相应的指令就去执行该指令
所谓编译执行,就是通过即时编译器JIT(just in Time)将字节码转换为本地机器码来执行; 现代JVM会将热点代码转换为本地机器码(与硬件强相关性,失去跨平台的优点)
基于栈的指令集与基于寄存器的指令集之间的关系:
1. JVM执行指令时所采取的方式是基于栈的指令集
2. 基于栈的指令集主要操作是入栈和出栈
3. 基于栈的指令集的优势在于它可以在不同的平台之间移植,而基于寄存器的指令集是与硬件架构紧密关联的,无法做到可移植
4. 基于栈的指令集的缺点在于完成相同的操作,指令数量通常要比基于寄存器的指令集数量要多; 基于栈的指令集是在内存中完成操作的,而基于寄存器的指令集是直接由CPU来执行的,它在高速缓存区中进行执行,速度要快很多,即使虚拟机可以采用一些优化手段,但总提来说,基于栈的指令集的值行速度要慢一些

jvm内存划分和作用
虚拟机栈: Stack Frame 栈帧
程序计数器: (Program Counter): 用于记录字节码的执行顺序 永远不会溢出
本地方法栈: 主要用于管理本地方法
堆(Heap): JVM管理的最大一块内存空间
方法区(Method Area); 存储元信息
永久代(Permanent Generarion),自JDK1.8之后废弃永久代,使用元空间(meta space)
运行是常量池: 方法区的一部分内容
直接内存(又称堆外内存): Direct Memory