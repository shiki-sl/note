[字节码表](./img/字节码表.png)
由字符串长度length长度为2个十六进制,说明编译期string长度最大为65534是因为 Javac 源码中做的限制是((String)constValue).length() < Pool.MAX_STRING_LENGTH) 注意是 < 而不是 <= ， 小于65535那自然最多只能是65534了。

1. 使用javap -verbose命令分析一个字节码时,将会分析该字节码文件的魔数,版本号,常量池,类信息,类的构造方法,类中的方法信息,类变量与成员变量等信息
2. 魔数: 所有的.class字节码文件的前4个字节都是魔数,魔数固定值为0xCAFEBABE.
3. 魔数之后的4个字节为版本信息,前两个字节表示minor version(次版本号),后面两个字节表示 manjor version(主板本号); 比如版本号为00 00 00 34表示主板本好52即jdk1.8 次版本号为0所以版本号为jdk1.8.0
4. 常量池(constant pool): 紧接着主版本号之后的就是常量池的入口; 一个java类中定义得很多信息都是由常量池来维护和描述的, 可以将常量池看作是Class文件的资源仓库, 比如java类中定义的方法与变量信息, 都是存储在常量池中; 常量池中主要存储两类常量: 字面量与符号引用; 字面量如文本字符串, java中声明为final的常量值等,而符号引用如类和接口得全限定名,字段的名称和描述符,方法的名称和描述符等.
5. 常量池的总体结构: java类所对应的常量池主要由常量池数量与常量池数组(常量表)这两部分共同构成; 常量池数量紧跟在主板笨号后面,占据2个字符; 常量池数组则紧跟在常量池数量之后; 常量池数组于一般的数组不同的是:常量池数组中不同的元素类型,数据结构都是不同的,长度当然也就不同;但是每一种元素的第一个数据都是由一个u1类型.该字节是个标志位,占据一个字节,JVM在解析常量池时,会跟据这个u1类型来获取元素的具体类型; 值得注意的是,常量池数组中元素的个数 = 常量池数 - 1 (其中0暂时不使用), 目的是满足某些常量池索引值的数据在特定情况下需要表达**不引用任何一个常量池**的含义; 根本原因在于,索引值为0也是一个常量(保留常量), 只不过它不位于常量表中,这个常量就对应**null**值;所以常量池的索引从1而非0开始
6. 在jvm规范中,每个变量/字段都有描述信息, 描述信息主要的作用是描述字段的数据类型,方法的参数列表(包括数量,类型与顺序)与返回值,根据描述规则, 基本数据类型和代表无返回值的void类型都用一个大写字母来表示, 对象类型则使用字符L加对象的全限定类名类来表示, 为了压缩文件字节码的体积,对于基本数据类型,JVM都只使用一个大写字母来表示,如下所示: B - byte , C - char , D - double , F - float , I - int , J - long , B - short , Z - boolean , V - void , L - 对象类型,如Ljava/lang/String
7. 对于数组类型来说, 每一各维度使用一个前置的[来表示,如int [] 被表示为[I,String [][]被表示为[[Ljava/lang/String;
8. 用描述符描述方法时,按照先参数列表,后返回值顺序来描述; 参数列表按照参数的严格顺序放在一组()内,如方法 String A(int i.String str)的描述符为: (I,Ljava/lang/String;) Ljava/lang/String;
9. Class字节码中有两种基本数据类型
    - 字节数据直接量: 这是基本的数据类型; 细分为u1,u2,u4,u8四种, 分别代表连续的1个字节,2个字节,4个字节,8个字节组成的整体数据
    - 表(数组): 表是由多个基本数据或其他表,按照既定顺序组成的大的数据集和; 表是有结构的,他的结构体现在: 组成表的成分所在的位置和顺序都是已经严格定义好的(不能有任何偏差)
##从字节码角度分析
###构造方法
会将初始化语句拼接到每一个构造方法中
```
priavte a = 1
-------------------
// a = 1实在构造方法中进行初始化的
<init>(){
    a = 1;
}
```
###异常处理
会将每一个finally中的字节码拼接到catch中

##栈帧(stack frame)
- 栈帧是一种用于帮助虚拟机执行方法调用与方法执行的数据结构
- 栈帧本身是一种数据结构,封装了方法的局部变量表,动态链接信息,方法的返回地址以及操作数栈等信息
- 符号引用,直接引用
有些符号引用是在类加载阶段或是第一次使用时就会转换为直接引用; 这种转换叫做静态解析; 另外一些符号引用则是在每次运行其转换为直接引用,这种转换叫做动态链接,这体现为java的多态性

1. invokeinterface: 调用接口中的方法,实际上是在运行期决定的,决定到底该调用实现该接口的哪个对象的特定方法
2. invokestatic: 调用静态方法
3. invokespecial: 调用自己的私有方法,构造方法(<init\>)以及父类的方法
4. invokevirtual: 调用虚方法,运行期动态查找的过程.
5. invokedynamic: 动态调用过程

- 静态解析的4种情形:
    1. 静态方法
    2. 父类方法
    3. 构造方法
    4. 私有方法(无法被重写)
以上四种被称为非虚方法,他们是在类加载阶段就可以将符号引用转换为直接引用的

- 方法的静态分派
Father f = new Son();
以上代码,f1的静态类型是Father,而f1的实际类型(真正指向的类型)则是Father
结论是: 变量的静态类型是不会发生变化的,而变量的实际类型则是可以发生变化的(多台的一种体现),实际类型是在运行期方可确定
- 方法的动态分派:
方法的动态分派涉及道一个重要概念:方法接受者
invokevirtual字节码指令的多态查找流程
比较方法重载(overload)与方法重写(overwrite),得到的结论是:方法重载是静态的,是编译期行为; 方法重写是动态的,是运行期行为
在运行期会先查找实际引用中是否存在与该方法(签名,描述符等)一致方法对象,存在就将其转换为直接直接引用,不存在就去自下至上查找父类

- 虚方法表: 
针对方法调用动态分派过程,虚拟机会在类的方法区建立一个虚方法表的数据结构(virtual method table, vtable)
存放的是每一个方法实际调用的真正的入口调用地址
- 接口方法表: 
针对invokeinterface指令来说,虚拟机会建立一个叫做接口方法表的数据结构(interface method table, itable)
- 对于子类中没有重写的方法来说,子类并不会在子类的虚方法表中再复制一份,而是直接指向父类中的方法入口地址,如果子类和父类存在重写关系的话,那么对于相同描述符的方法来说,在子类和父类中的虚方法表中的索引位置是一致的,减少了查找得成本和存放空间