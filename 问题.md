**一 redis 五种数据结构 **                 常用
1.      string: 基本字符串           json,验证码等简单信息
2.      set:    不重复的集合         用的较少,大概能用于同一实体对多个不同实体的唯一操作(一个用户购买了很多唯一限定的物品)
3.      list:   可重复集合           链表,能在两端进行插入和删除操作
4.      hash:   hash表              多个key关联性较强,可以抽象成为一个整体
5.      strongList: 带权可重复集合   带权重的集合, 适用于缓存元素需要进行排序时


**二 redis的hash实现:**

**参考**[Redis源码剖析--哈希对象t_hash实现](https://blog.csdn.net/harleylau/article/details/80612616)

底层编码格式有两种: ziplist和hashtable
- hash对象同时满足以下两种条件时 使用ziplist进行编码
    1. hash对象保存的所有键值对的键和值的字符串长度都小于64字节
    2. hash对象保存的键值对数量小于512个
- 不能满足条件的hash对象需要使用hashtable编码

阈值可以自行设定

    redis.conf中配置 
        hash-max-ziplist-value 64       最大放值长度
        hash-max-ziplist-entries 214    最多entry节点数量
当所需任一条件不被满足时,ziplist就会转化为hashtable且过程不可逆,其中所有的键值对都会被转移并保存到字典中

使用ziplist实现时,每次插入一个新的键值对,程序会先将保存了键的压缩列表节点推到压缩列表表尾,然后再将保存了值的压缩列表节点推入压缩列表表尾 类似下图所示

```
    |zlbytes | zltail | zllen |   entry1  |  entry2  |   entry3  |   entry4  | zlend |
                                ↓          ↓           ↓           ↓    
                          |    key1   |  value1  |    key2   |   value2  |

```

**三 rehash 过程和 javaHashMap rehash区别**

- redis rehash是渐进式hash,创建时默认大小是4, 扩容倍率是2, 在扩容时并不会直接将元素放入新hash表中, 而是在每次对表执行操作时将(h0)原表中数据放入新表(h1)中,每次扩容二倍可以保证在h1需要扩容时h0中的数据全部被放入新表中, 这么做是因为redis是单线程的,如果直接将老数据全部倒入新表那么当hash表体积大之后, 每次扩容性能会很差
- 和java区别: java hashMap扩容是当实际存储元素的大小达到字典大小的.75是进行扩容, 在jdk1.8之后扩容时不再重新计算key的hashCode,而是通过低位和高位的与操作来直接移动hashcode值 
- java所有基于map的类都不允许在保存后更改保存元素hashcode值的行为, 除非先移除更改后重新添加

**四 redis cluster有没有了解过，怎么做到高可用的？**  
[redis cluster集群](https://www.cnblogs.com/xifenglou/p/9173419.html)  
redis cluster是一个官方推荐的无中心集群
1. 每个节点间两两互联(PING-PONG机制),使用二进制协议优化传输速度和带宽
2. 节点的fail是通过集群中超过半数的节点检测失效时才失效(半数节点不能ping通的节点为失效节点)
3. 客户端与redis节点直连, 不需要中间proxy层, 客户端只需要连接集群中任意一台可用节点即可
4. redis cluster将物理节点映射为[0-16383]slot上(不一定是平均分配),cluster负责维护node<->slot<->value
5. redis集群预分好16384个桶,根据CRC16(key) mod 16384的值,决定将key放置到哪个桶当中
redis cluster需要奇数个节点(3个起步),每个节点可以分配从节点,主节点挂掉之后使用从节点顶替,每次在保存值时,主节点和从节点同时进行保存  

一个节点及从节点挂掉之后,只有节点对应的key不能访问,其余节点能够正常访问  
hash槽数量是 16384 的原因是因为在 redis 节点发送心跳包时会把所有的槽放入心跳包中,而 16384=16k 在经过bitmap压缩后是2k,虽然 CRC16 算法最多支持65535个槽位,但是 65535=64k , 压缩后 8k, 也就是心跳包要发送8k, 作者认为这样不值得, 而且一般情况下redis集群中不会有超过1000个master节点,所以16k槽位比较适合

**五 说说redis的持久化机制，为啥不能用redis做专门的持久化数据库存储？**  
    持久化机制 
        1. 实时保存,插入一条写入磁盘一条
        2. 固定时间间隔内插入达到阈值进行保存
    不能作为专门的持久化数据库存储的原因是: 
        存储数据时大部分的性能都消耗在io操作上, 而redis是单线程的内存数据库, 如果实时保存, 性能下降很厉害

**六 了不了解tcp/udp，说下两者的定义，tcp为什么要三次握手和四次挥手？**  
[参考资料来源](https://www.cnblogs.com/cenglinjinran/p/8482412.html)
- tcp/传输控制协议      保证数据真实性,允许数据包随机发送,在接受后进行排序,丢包重传
- udp/用户数据报协议    面向无连接的协议 尽最大可能传输,也就是说并不能保证数据报一定真实可靠地送达

tcp三次握手是为了确认双方主机是否处于正常可连接状态
- 第一次: 客户端发送syn(syn=j)包请求服务端建立连接
- 第二次: 服务端收到syn包并确认syn(ack=j+1),同时自己也发送一个syn包(seq=k),此时服务端进入SYN_SEED状态
- 第三次: 客户端收到服务器syn+ack包,并向服务器发送确认包ack(ack=k+1),发送完毕进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

第一次握手效验客户端的发送能力和服务端的接受能力  
第二次握手效验客户端的接受能力和服务端的发送能力  
    前两次握手已经确保双方的收发状态处于正常可以进行交互, 但是还是进行第三次握手是为了保证连接的时效性, 也就是说是为了保证服务端接收到的包具有时效性, 因为存在网络阻塞客户端超时重传或者其他情况下接收到无效的请求, 浪费服务端资源

四次挥手是为了保证双方正在发送的数据可以发送完成, 当前请求不会被中断
前两次挥手是用于断开一个方向的连接,后两次挥手是为了断开另一个方向的连接
- 第一次挥手: 如A认为数据发送完成,则它要向B发送一条连接释放请求 该请求只有报文头,头中携带信息主要参数是
    FIN=1, sep=u,此时A进入FIN-WAIT-1状态
        FS1: FIN=1表示该报文段是一个连接释放的请求
        FS2: seq=u,u-1是A向B发送的最后一个字节的序号
- 第二次挥手: B收到连接释放请求后,会通知相应的应用程序, 告诉A向B这个方向的链接已经释放, 此时B进入CLSOE-WAIT状态, 并将A发送连接释放应答, 其报文头包含:
    ACK=1,seq=v,ack=u+1
        PS1: ACK=1: 除TCP连接请求报文段以外, TCP通信过程中所有的数据报的ACK都为1, 表示应答
        PS2: seq=v, v-1是B向A发送的最后一个字节的序号
        PS3: ACK=u+1表示希望接受到从第u+1个字节开始的报文段,并且已经成功接受到了前u个字节
- 第三次挥手: 当B向A发完所有数据后,向A发送连接释放请求,请求头: FIN=1,ACK=1,seq=w,ack=u+1; B进入LAST-ACK状态
- 第四次挥手: A收到释放请求后,向B发送确认应答,此时A进入TIME-WAIT状态. 该状态会持续2MSL时间,若该时间段内没有收到B的重发请求的话,就进入CLOSED状态,撤销TCB. 当B收到确认应答后. 也便进入CLOSED状态,撤销TCB  

**为什么A要先进入TIME-WAIT状态等待2MSL(报文最长存活时间)时间后才进入CLOSE状态**  
是为了保证B能收到A的确认应答, 若A发完确认应答后直接进入CLOSED状态, 那么如果该应答丢失, B等待超时后就会重新发送连接释放请求, 但此时A已经关闭了, 不会做出任何响应,因此B永远无法正常关闭

**七 tcp怎么保证有序传输的，讲下tcp的快速重传和拥塞机制**  
    tcp 有大约80b的头文件,其中包含版本号,协议,当前报文大小,数据偏移量,校检和,是否拥有后续包,填充位等  
    tcp 快重传和拥塞是联系在一起的, 拥塞是由于发送方不知道当前信道的利用率,导致发送的数据报占用信道资源过多, 使得带宽占用过高, 接受方长时间得不到响应或者某些包传输过慢,接收方认为丢包要求重传等,   快重传为了尽量避免拥塞情况, 发包速率是按2次幂的速度提升的 初始是一,二倍增长,到达增长阈值就开始线性增长, 当出现拥塞时,将传输速率降低一半, 然后继续线性增长 以达到尽可能的利用信道  

**八 知不知道time_wait状态，这个状态出现在什么地方，有什么用？**  
[解决TIME_WAIT过多造成的问题](https://www.cnblogs.com/dadonggg/p/8778318.html)  
time_wait状态出现在tcp四次挥手的第四次握手, 处于释放连接的最终确认阶段, 主动断开连接方在收到对方的释放请求时, 会向对方发送确认应答请求, 该状态持续2MSL,MSL要大于TTL(time to live: 是报文的最大存活时间,实际上是路由的有效跳转数,占用2字节的无符号数,在经过255次转发后报文在网络中就被丢弃了,是为了防止在两个交换机之间的循环转发),反应到时间上 标准规定是两分钟,实际常用30s,1分钟和2分钟

要实现TCP协议的正常终止, 需要处理四次挥手中的任何一个节点丢失的情况

在高并发短连接的服务器上, 当服务器处理完请求后立刻主动正常关闭连接. 这个场景下会出现大量的socket处于TIME_WAIT状态. 如果客户端的并发量持续很高,此时部分客户端就会显示连接不上,主动正常关闭TCP连接, 都会出现TIMEWAIT.  

为是么要关注这个**高并发短连接**?
- 1高并发可以让服务器在短时间内同时占用大量端口, 而端口实际可用范围1024-65535,去除mysql等其他服务站用的端口, 剩下可用的就更少了
- 在这个场景下, 短连接表示"**业务处理+传出数据的时间 远远小于TIMEWAIT超时时间**"的连接
长连接不需要考虑TIMEWAIT, 在实际业务场景中**一般长连接对应的业务并发量不会很高**

**九 udp是不可靠的传输，如果你来设计一个基于udp差不多可靠的算法，怎么设计？**  
udp主要用于通信之类实时性要求高于一致性的地方, 思路为尽可能的可靠, 但是更多地是保证时效性  
使用udp进行模拟tcp;  
在发送前发一个包,包含一些必要信息,比如完整时间戳等, 接收方收到报文后回写带有必要信息的报文, 在数据报上面加上时间戳, 接收方接到数据延时一定时间(1~5s)在延迟时间冲等待数据报并进行排序 重传(尽可能的重传,重传次数与延时时间相关), 将排好序的数据报解析传递给用户, 由于整体存在延迟,在用户看来只是连接时间变慢,影响不大

**十 http与https有啥区别？说下https解决了什么问题，怎么解决的？说下https的握手过程。**  
[资料来源:我是这样理解HTTP和HTTPS区别的](https://www.cnblogs.com/jesse131/p/9080925.html)  
[HTTP和HTTPS协议，看一篇就够了](https://blog.csdn.net/xiaoming100001/article/details/81109617)  
http1.0 每次请求的短连接  
http1.1 支持长连接  
https 近似可以认为套上ssl协议的http  
http协议使用明文进行传输(重要信息泄露),不验证身份(无状态,csrf),无法验证报文完整性(常见的运行商劫持)  
http特点: 

1. 无状态:协议对客户端没有状态储存,对事物处理没有"记忆"能力,比如访问一个网站需要反复进行登录操作
2. 无连接:HTTP/1.1之前,  由于无状态特点,  每次请求需要经过三次握手四次挥手,  和服务器重新建立连接; 
3. 基于请求和响应: 基本的特征,  由客户端发起请求,  服务端响应
4. 简单快速、灵活
5. 通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性

https特点:

1. 内容加密: 采用混合加密技术,  中间者无法直接查看明文内容
2. 验证身份: 通过证书认证客户端访问的是自己的服务器
3. 保护数据完整性: 防止传输的内容被中间人冒充或者篡改

> 混合加密: 结合对称加密与非对称加密技术。客户端使用对称机密生成的密钥对传输数据进行机密，然后使用分对称加密的公钥在对秘钥进行加密，所以网上传输的数据是被公钥加密的密文何用公钥加密后的秘密密钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的的密钥，便无法获取到明文数据。
>
> 数字摘要：不能还原的叫摘要，能还原的叫加密
>
> 数字签名技术：数字签名建立在公钥加密体制的基础上，是公钥加密技术的另一类应用。他把公约加密技术和数字摘要结合起来，形成了实用的数字签名技术
>
> - 收方能够验证发送方的真实身份
> - 发送方事后不能否认所发送过的报文
> - 收方或非法者不能伪造、篡改报文

解决的是http无状态不安全的问题

1. client请求server，并连接到443端口
2. server端必须要有一套数字证书（自行制作浏览器会有提示界面）
3. 传送证书（公钥）
4. client解析证书，解析无误生成密钥，然后使用证书对其加密
5. 传送加密信息：将密钥传递给server，然后c/s间就可以使用密钥对其进行加密了
6. server加密信息：server通过私钥解密密钥，得到客户端的私钥，然后把内容通过私钥对称加密
7. 传输加密信息：这部信息事用服务端的私钥加密后的信息，可以在client端还原。
8. client端解密：使用生成的的私钥解密信息

如何保证s端的公钥可靠性，使用第三方验证，第三方根据s端域名生成数字证书，然后在公钥中带入。c端使用第三方的公钥验证数字证书  

> HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用
>
> SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行



**十一 看你项目里面用了etcd，讲解下etcd干什么用的，怎么保证高可用和一致性？**

**十二 既然你提到了raft算法，讲下raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？**

**十三 有没有了解过paxos和zookeeper的zab算法，他们之前有啥区别？**

**十四 你们后端用什么数据库做持久化的？有没有用到分库分表，怎么做的？**

mysql,使用中间件mycat 分库分表可以垂直切分和水平切分, 垂直切分就是将表存储在不同db中, 水平切分是将同一张表按一定规则, 比如日志表每个月区分并且放入不同数据库, 视频网站按照视频是否下架将视频区分存储等..

**十五 索引的常见实现方式有哪些，有哪些区别?**

**十六 MySQL的存储引擎有哪些，有哪些区别？**
InnoDB和Myi

**十七 InnoDB使用的是什么方式实现索引，怎么实现的？说下聚簇索引和非聚簇索引的区别?**

**十八 有没有了解过协程？说下协程和线程的区别？**
 协程不会出现线程安全问题

**十九 算法题一个，剑指offer第51题，数组中的重复数字？**